{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Luxcena-Neo Dependencies Branch (dev) Install Please refer to this guide for installing: Install Luxcena-neo . Issues There might still be a bit hard for someone not having spent hours looking at the source to use this software. The hope is that it will be more useable for every new update. Chrome is the ONLY tested browser, there is no reason it shouldn't work in other modern browsers as well. But you might see some weird behaviour.","title":"Introduction"},{"location":"#luxcena-neo","text":"Dependencies Branch (dev)","title":"Luxcena-Neo"},{"location":"#install","text":"Please refer to this guide for installing: Install Luxcena-neo .","title":"Install"},{"location":"#issues","text":"There might still be a bit hard for someone not having spent hours looking at the source to use this software. The hope is that it will be more useable for every new update. Chrome is the ONLY tested browser, there is no reason it shouldn't work in other modern browsers as well. But you might see some weird behaviour.","title":"Issues"},{"location":"FuturePlan/","text":"Plans for the future Planned and implemented Add authentication to our middelware. Make service worker cache bundles localy on client, and use a spinner when loading them. PWA. Do some kind of code-splitting as well here. Socketio Rewrite socketio to use auth Make all action respond to the client, so that it knows wether the action was a success or not. Make timout thing. Make logout function Rewrite public-dir to load pages with javascript, and have one handler, instead of a seperate html file per page. Neo IDE Add intellisense for neo_behaviour Make alternative to scripting, something like mindstorms or scratch block-coding, (blockly). Setup GitHub pages https://www.mkdocs.org/user-guide/deploying-your-docs/ Make update-button Think about making it auto-update. Ideas that might get implemented at some point in time Make a ws281x-library that doesn't require root. Check OS security-patch setup Get diff-thingy on local scripts/ Git tracking Maybe add a rest API","title":"Plan for the future"},{"location":"FuturePlan/#plans-for-the-future","text":"","title":"Plans for the future"},{"location":"FuturePlan/#planned-and-implemented","text":"Add authentication to our middelware. Make service worker cache bundles localy on client, and use a spinner when loading them. PWA. Do some kind of code-splitting as well here. Socketio Rewrite socketio to use auth Make all action respond to the client, so that it knows wether the action was a success or not. Make timout thing. Make logout function Rewrite public-dir to load pages with javascript, and have one handler, instead of a seperate html file per page. Neo IDE Add intellisense for neo_behaviour Make alternative to scripting, something like mindstorms or scratch block-coding, (blockly). Setup GitHub pages https://www.mkdocs.org/user-guide/deploying-your-docs/ Make update-button Think about making it auto-update.","title":"Planned and implemented"},{"location":"FuturePlan/#ideas-that-might-get-implemented-at-some-point-in-time","text":"Make a ws281x-library that doesn't require root. Check OS security-patch setup Get diff-thingy on local scripts/ Git tracking Maybe add a rest API","title":"Ideas that might get implemented at some point in time"},{"location":"Code Documentation/SocketIO/","text":"SocketIO Client Socketio is setup in the file globals . This means, import globals , and then you can use Socket from there. Connect Client first needs to get an Authentication token, this can be obtained by doing this: 1 2 3 4 5 6 7 8 9 import { setCookie } from \"../../../cookies\" ; let CryptoJS = require ( \"crypto-js\" ); let passwordHash = CryptoJS . SHA256 ( < PASSWORD > ;). toString (); Socket . emit ( \"authenticate\" , < USERNAME > , passwordHash , ( token ) => { // Token will be a string if username/password combo is right, // if not, it is false. setCookie ( \"session_token\" , token , 500 ); };) Then the user can authenticate like this: 1 2 3 4 5 6 7 import { getCookie } from \"../../../cookies\" ; let cookieToken = getCookie ( \"session_token\" ); Socket . emit ( \"authenticateToken\" , cookieToken , ( res ) => { // Res is true if we got authenticated, // If not, it is false. }); We are now authenticated, and all actions and events are available to the client. \"Actions\" 1 2 Socket . emit ( Action , * Arguments , ( Return ) => { };) NeoRuntime/status Name Type Description status object Return/status Name Type Description currentScript string \"None\"/Name of current script scriptIsExited boolean uptime number NeoRuntime/Script/Create Arguments Name Type Description scriptPath string Path of the new script, local/example Return Name Type Description res boolean success resMsg string if fail, errorMessage NeoRuntime/Script/Delete Arguments Name Type Description scriptPath string Path of the script to delete, local/example Return Name Type Description res boolean success resMsg string if fail, errorMessage NeoRuntime/Script/Select Arguments Name Type Description scriptPath string Path of the script to start, local/example NeoRuntime/Scripts/get Return Name Type Description local list local scripts remote list remote scripts \"Events\" 1 2 3 4 5 // Listen for a event Socket . emit ( event + \"::join\" ); Socket . on ( event , ( * Return ); => { }) 1 2 // Stop listening for an event Socket . emit ( event + \"::leave\" ) Server","title":"Socket-IO"},{"location":"Code Documentation/SocketIO/#socketio","text":"","title":"SocketIO"},{"location":"Code Documentation/SocketIO/#client","text":"Socketio is setup in the file globals . This means, import globals , and then you can use Socket from there.","title":"Client"},{"location":"Code Documentation/SocketIO/#connect","text":"Client first needs to get an Authentication token, this can be obtained by doing this: 1 2 3 4 5 6 7 8 9 import { setCookie } from \"../../../cookies\" ; let CryptoJS = require ( \"crypto-js\" ); let passwordHash = CryptoJS . SHA256 ( < PASSWORD > ;). toString (); Socket . emit ( \"authenticate\" , < USERNAME > , passwordHash , ( token ) => { // Token will be a string if username/password combo is right, // if not, it is false. setCookie ( \"session_token\" , token , 500 ); };) Then the user can authenticate like this: 1 2 3 4 5 6 7 import { getCookie } from \"../../../cookies\" ; let cookieToken = getCookie ( \"session_token\" ); Socket . emit ( \"authenticateToken\" , cookieToken , ( res ) => { // Res is true if we got authenticated, // If not, it is false. }); We are now authenticated, and all actions and events are available to the client.","title":"Connect"},{"location":"Code Documentation/SocketIO/#actions","text":"1 2 Socket . emit ( Action , * Arguments , ( Return ) => { };)","title":"\"Actions\""},{"location":"Code Documentation/SocketIO/#neoruntimestatus","text":"Name Type Description status object Return/status Name Type Description currentScript string \"None\"/Name of current script scriptIsExited boolean uptime number","title":"NeoRuntime/status"},{"location":"Code Documentation/SocketIO/#neoruntimescriptcreate","text":"Arguments Name Type Description scriptPath string Path of the new script, local/example Return Name Type Description res boolean success resMsg string if fail, errorMessage","title":"NeoRuntime/Script/Create"},{"location":"Code Documentation/SocketIO/#neoruntimescriptdelete","text":"Arguments Name Type Description scriptPath string Path of the script to delete, local/example Return Name Type Description res boolean success resMsg string if fail, errorMessage","title":"NeoRuntime/Script/Delete"},{"location":"Code Documentation/SocketIO/#neoruntimescriptselect","text":"Arguments Name Type Description scriptPath string Path of the script to start, local/example","title":"NeoRuntime/Script/Select"},{"location":"Code Documentation/SocketIO/#neoruntimescriptsget","text":"Return Name Type Description local list local scripts remote list remote scripts","title":"NeoRuntime/Scripts/get"},{"location":"Code Documentation/SocketIO/#events","text":"1 2 3 4 5 // Listen for a event Socket . emit ( event + \"::join\" ); Socket . on ( event , ( * Return ); => { }) 1 2 // Stop listening for an event Socket . emit ( event + \"::leave\" )","title":"\"Events\""},{"location":"Code Documentation/SocketIO/#server","text":"","title":"Server"},{"location":"Code Documentation/Design/","text":"Design We are using googles material design. Link to the components","title":"Design"},{"location":"Code Documentation/Design/#design","text":"We are using googles material design. Link to the components","title":"Design"},{"location":"Code Documentation/Modules/CompileAndRun/","text":"Index Locals var pythonSupportFiles Points to the files for our python support code. They should be in a subdir of the module itself. Exported class Python This is exported as Python, just so that we could add other languages later. Used to build and run python-scripts with our support-code. method Python . constructor Takes one parameter, which is the full path to the folder where the script is located. When initializing the class, this will be called. Can be done like this: 1 new compileRun . Python ( global . DirSwap + \"/usrData/usrCode/example\" ); method Python . compile This deletes old build-folder, and makes a new one. It then moves all required files into the build-folder, making us ready for running the script. method Python . run Spawns a new process, starting entry.py in our build-folder. It also attaches event-listners on our class-object. All of them is in the example below: 1 2 3 4 5 6 7 8 9 10 11 12 let sc = new compileRun . Python ( global . DirSwap + \"/usrData/usrCode/example\" ); \u200b // When data is printed from the python-script sc . on ( \"stdout::data\" , ( _stdout ) => { }); // Last write when script closes, any exiting messages sc . on ( \"stdout::end\" , ( _stdout ) => { }); // When something is printed from the python-script to the error-out. Usually when a `throw` is called sc . on ( \"stderr::out\" , ( _stderr ) => { }); // Last words when process is dying from an error :`( sc . on ( \"stderr::end\" , ( _stderr ) => { }); // When script exits, _code is the exit-code sc . on ( \"close\" , ( _code ) => { }); Python This is the support-files for user-made scripts. Entry.py The entry-point when running a script. A file called script.py, containing the user-script, should be placed next to this file. Starting it should be done like this (Where app-root is where our app.js is located): 1 python entry . py < pathToAppRoot >","title":"CompileAndRun"},{"location":"Code Documentation/Modules/CompileAndRun/#index","text":"","title":"Index"},{"location":"Code Documentation/Modules/CompileAndRun/#locals","text":"","title":"Locals"},{"location":"Code Documentation/Modules/CompileAndRun/#var-pythonsupportfiles","text":"Points to the files for our python support code. They should be in a subdir of the module itself.","title":"var pythonSupportFiles"},{"location":"Code Documentation/Modules/CompileAndRun/#exported","text":"","title":"Exported"},{"location":"Code Documentation/Modules/CompileAndRun/#class-python","text":"This is exported as Python, just so that we could add other languages later. Used to build and run python-scripts with our support-code.","title":"class Python"},{"location":"Code Documentation/Modules/CompileAndRun/#method-pythonconstructor","text":"Takes one parameter, which is the full path to the folder where the script is located. When initializing the class, this will be called. Can be done like this: 1 new compileRun . Python ( global . DirSwap + \"/usrData/usrCode/example\" );","title":"method Python.constructor"},{"location":"Code Documentation/Modules/CompileAndRun/#method-pythoncompile","text":"This deletes old build-folder, and makes a new one. It then moves all required files into the build-folder, making us ready for running the script.","title":"method Python.compile"},{"location":"Code Documentation/Modules/CompileAndRun/#method-pythonrun","text":"Spawns a new process, starting entry.py in our build-folder. It also attaches event-listners on our class-object. All of them is in the example below: 1 2 3 4 5 6 7 8 9 10 11 12 let sc = new compileRun . Python ( global . DirSwap + \"/usrData/usrCode/example\" ); \u200b // When data is printed from the python-script sc . on ( \"stdout::data\" , ( _stdout ) => { }); // Last write when script closes, any exiting messages sc . on ( \"stdout::end\" , ( _stdout ) => { }); // When something is printed from the python-script to the error-out. Usually when a `throw` is called sc . on ( \"stderr::out\" , ( _stderr ) => { }); // Last words when process is dying from an error :`( sc . on ( \"stderr::end\" , ( _stderr ) => { }); // When script exits, _code is the exit-code sc . on ( \"close\" , ( _code ) => { });","title":"method Python.run"},{"location":"Code Documentation/Modules/CompileAndRun/#python","text":"This is the support-files for user-made scripts.","title":"Python"},{"location":"Code Documentation/Modules/CompileAndRun/#entrypy","text":"The entry-point when running a script. A file called script.py, containing the user-script, should be placed next to this file. Starting it should be done like this (Where app-root is where our app.js is located): 1 python entry . py < pathToAppRoot >","title":"Entry.py"},{"location":"Code Documentation/Run/","text":"Run when developing I have made a simple script, that can be run both on a rPI and a normal computer. (You will obviously not get any script to do anything on you pc) I have only tested this on my mac... To start it run: 1 npm run dev You have to run these commands beforehand: 1 2 npm i pip3 install mkdocs mkdocs-gitbook pygments pymdown-extensions Starting It will when starting freak out a little. All the filewatchers fires an event for every file, they find for some reason. But node should be killed each time, and when you end up with only two processes, it should work as you'd expect. This will create a folder named tmp in you working directory. where all the user-files will be stored. Build watcher. It starts to watch these directories: 1 - / build / If a change is detected, it runs: 1 mkdocs build Node watcher It starts to watch these directories: 1 2 - src / ( Except / src / public / and / src / js / ) - app . js It then shuts down node and starts it again: 1 node app.js <WORKING_DIR>/tmp/ webpack It just starts this command, witch rebundles when anything is changed: 1 npx webpack -p -w --mode = development Tip All the log-windows respond to holding your cursor over and scrolling. Exit The script will exit when pressing q , s , escape , Control + c . It will then send a kill signal to all processes, wait 10 seconds and then exit. Edit file-watchers. Each of the file-watchers have explanatory names: watcher_node and watcher_docs . To add files or paths they should watch, find the init of the variable, and modify that code: 1 2 3 4 5 6 e . g . let ; watcher_node = chokidar . watch ([ \"app.js\" , 'src/' // Add new entrys here ]). on ( 'all' , ( event , path ) => { // ... For the node-watcher, specify paths it should ignore in the path . includes block.","title":"Run"},{"location":"Code Documentation/Run/#run-when-developing","text":"I have made a simple script, that can be run both on a rPI and a normal computer. (You will obviously not get any script to do anything on you pc) I have only tested this on my mac... To start it run: 1 npm run dev You have to run these commands beforehand: 1 2 npm i pip3 install mkdocs mkdocs-gitbook pygments pymdown-extensions Starting It will when starting freak out a little. All the filewatchers fires an event for every file, they find for some reason. But node should be killed each time, and when you end up with only two processes, it should work as you'd expect. This will create a folder named tmp in you working directory. where all the user-files will be stored.","title":"Run when developing"},{"location":"Code Documentation/Run/#build-watcher","text":"It starts to watch these directories: 1 - / build / If a change is detected, it runs: 1 mkdocs build","title":"Build watcher."},{"location":"Code Documentation/Run/#node-watcher","text":"It starts to watch these directories: 1 2 - src / ( Except / src / public / and / src / js / ) - app . js It then shuts down node and starts it again: 1 node app.js <WORKING_DIR>/tmp/","title":"Node watcher"},{"location":"Code Documentation/Run/#webpack","text":"It just starts this command, witch rebundles when anything is changed: 1 npx webpack -p -w --mode = development Tip All the log-windows respond to holding your cursor over and scrolling.","title":"webpack"},{"location":"Code Documentation/Run/#exit","text":"The script will exit when pressing q , s , escape , Control + c . It will then send a kill signal to all processes, wait 10 seconds and then exit.","title":"Exit"},{"location":"Code Documentation/Run/#edit-file-watchers","text":"Each of the file-watchers have explanatory names: watcher_node and watcher_docs . To add files or paths they should watch, find the init of the variable, and modify that code: 1 2 3 4 5 6 e . g . let ; watcher_node = chokidar . watch ([ \"app.js\" , 'src/' // Add new entrys here ]). on ( 'all' , ( event , path ) => { // ... For the node-watcher, specify paths it should ignore in the path . includes block.","title":"Edit file-watchers."},{"location":"Scripting/Examples/strandtest/","text":"Strandtest This script just does some fancy patterns to show of the neopixels' capabilities. Runs in an endless loop, take a look at the code to see what it does more precisely. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import LuxcenaNeo as neo # Can be imported as LuxcenaNeo as well. but anything else and it will fail... import time def colorWipe ( color , wait_ms = 50 ): \"\"\"Wipe color across display a pixel at a time.\"\"\" for i in range ( neo . strip . numPixels ()): neo . strip . setPixelColor ( i , color ) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def theaterChase ( color , wait_ms = 50 , iterations = 10 ): \"\"\"Movie theater light style chaser animation.\"\"\" for j in range ( iterations ): for q in range ( 3 ): for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , color ) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , 0 ) def wheel ( pos ): \"\"\"Generate rainbow colors across 0-255 positions.\"\"\" if pos < 85 : return neo . Color ( pos * 3 , 255 - pos * 3 , 0 ) elif pos < 170 : pos -= 85 return neo . Color ( 255 - pos * 3 , 0 , pos * 3 ) else : pos -= 170 return neo . Color ( 0 , pos * 3 , 255 - pos * 3 ) def rainbow ( wait_ms = 20 , iterations = 1 ): \"\"\"Draw rainbow that fades across all pixels at once.\"\"\" for j in range ( 256 * iterations ): for i in range ( neo . strip . numPixels ()): neo . strip . setPixelColor ( i , wheel (( i + j ) & 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def rainbowCycle ( wait_ms = 20 , iterations = 5 ): \"\"\"Draw rainbow that uniformly distributes itself across all pixels.\"\"\" for j in range ( 256 * iterations ): for i in range ( strip . numPixels ()): neo , strip . setPixelColor ( i , wheel ((( i * 256 / neo . strip . numPixels ()) + j ) & 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def theaterChaseRainbow ( wait_ms = 50 ): \"\"\"Rainbow movie theater light style chaser animation.\"\"\" for j in range ( 256 ): for q in range ( 3 ): for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , wheel (( i + j ) % 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , 0 ) class Main ( neo . NeoBehaviour ): def onStart ( self ): # Change the brightness of the strip neo . strip . setBrightness ( 100 ) # Do an endless loop with some default neopixel test patterns while True : colorWipe ( neo . Color ( 255 , 0 , 0 )) # Red wipe colorWipe ( neo . Color ( 0 , 255 , 0 )) # Blue wipe colorWipe ( neo . Color ( 0 , 0 , 255 )) # Green wipe theaterChase ( neo . Color ( 127 , 127 , 127 )) # White theater chase theaterChase ( neo . Color ( 127 , 0 , 0 )) # Red theater chase theaterChase ( neo . Color ( 0 , 0 , 127 )) # Blue theater chase rainbow () rainbowCycle () theaterChaseRainbow ()","title":"Strandtest"},{"location":"Scripting/Examples/strandtest/#strandtest","text":"This script just does some fancy patterns to show of the neopixels' capabilities. Runs in an endless loop, take a look at the code to see what it does more precisely. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import LuxcenaNeo as neo # Can be imported as LuxcenaNeo as well. but anything else and it will fail... import time def colorWipe ( color , wait_ms = 50 ): \"\"\"Wipe color across display a pixel at a time.\"\"\" for i in range ( neo . strip . numPixels ()): neo . strip . setPixelColor ( i , color ) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def theaterChase ( color , wait_ms = 50 , iterations = 10 ): \"\"\"Movie theater light style chaser animation.\"\"\" for j in range ( iterations ): for q in range ( 3 ): for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , color ) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , 0 ) def wheel ( pos ): \"\"\"Generate rainbow colors across 0-255 positions.\"\"\" if pos < 85 : return neo . Color ( pos * 3 , 255 - pos * 3 , 0 ) elif pos < 170 : pos -= 85 return neo . Color ( 255 - pos * 3 , 0 , pos * 3 ) else : pos -= 170 return neo . Color ( 0 , pos * 3 , 255 - pos * 3 ) def rainbow ( wait_ms = 20 , iterations = 1 ): \"\"\"Draw rainbow that fades across all pixels at once.\"\"\" for j in range ( 256 * iterations ): for i in range ( neo . strip . numPixels ()): neo . strip . setPixelColor ( i , wheel (( i + j ) & 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def rainbowCycle ( wait_ms = 20 , iterations = 5 ): \"\"\"Draw rainbow that uniformly distributes itself across all pixels.\"\"\" for j in range ( 256 * iterations ): for i in range ( strip . numPixels ()): neo , strip . setPixelColor ( i , wheel ((( i * 256 / neo . strip . numPixels ()) + j ) & 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) def theaterChaseRainbow ( wait_ms = 50 ): \"\"\"Rainbow movie theater light style chaser animation.\"\"\" for j in range ( 256 ): for q in range ( 3 ): for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , wheel (( i + j ) % 255 )) neo . strip . show () time . sleep ( wait_ms / 1000.0 ) for i in range ( 0 , neo . strip . numPixels (), 3 ): neo . strip . setPixelColor ( i + q , 0 ) class Main ( neo . NeoBehaviour ): def onStart ( self ): # Change the brightness of the strip neo . strip . setBrightness ( 100 ) # Do an endless loop with some default neopixel test patterns while True : colorWipe ( neo . Color ( 255 , 0 , 0 )) # Red wipe colorWipe ( neo . Color ( 0 , 255 , 0 )) # Blue wipe colorWipe ( neo . Color ( 0 , 0 , 255 )) # Green wipe theaterChase ( neo . Color ( 127 , 127 , 127 )) # White theater chase theaterChase ( neo . Color ( 127 , 0 , 0 )) # Red theater chase theaterChase ( neo . Color ( 0 , 0 , 127 )) # Blue theater chase rainbow () rainbowCycle () theaterChaseRainbow ()","title":"Strandtest"},{"location":"Scripting/SupportLib/","text":"Support Library class Strip This is the object you are refeering to when you want to do things with LED's. You shouldn't have to do instantiate your own new strip-object as you can use the one set up by the software itself. 1 2 3 LuxcenaNeo . strip or neo . strip Strip.show() Display all the changes made to the LEDs, on the actual LEDs. Strip.setPixelColor( n , color ) Set LED at position n to the provided 24-bit color value (in RGB order). Strip.setPixelColorXY( x , y , color ) Set LED at position (x, y) in the defined matrix to the provided 24-bit color value (in RGB order). Strip.setPixelColorRGB( n , red , green , blue , white = 0 ) Set LED at position n to the provided red, green, and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity). Strip.setPixelColorXYRGB( x , y , red , green , blue , white = 0 ) Set LED at position (x, y) in the defined matrix to the provided red, green, and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity). Strip.setSegmentColorRGB( segment , red , green , blue , white = 0 ) Set a whole segment to the provided red, green and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity). Strip.setBrightness( brightness ) Scale each LED in the buffer by the provided brightness. A brightness of 0 is the darkest and 255 is the brightest. Strip.getBrightness(): Get the brightness value for each LED in the buffer. A brightness of 0 is the darkest and 255 is the brightest. Strip.getPixels(): Return an object which allows access to the LED display data as if it were a sequence of 24-bit RGB values. Strip.numPixels(): Return the number of pixels in the display. Strip.getPixelColor( n ) Get the 24-bit RGB color value for the LED at position n. Color( red , green , blue , white = 0 ) Convert the provided red, green, blue color to a 24-bit color value. Each color component should be a value 0-255 where 0 is the lowest intensity and 255 is the highest intensity. hexColor( value ) Convert the provided hexadecimal color to a 24-bit color value.","title":"Support Library"},{"location":"Scripting/SupportLib/#support-library","text":"","title":"Support Library"},{"location":"Scripting/SupportLib/#class-strip","text":"This is the object you are refeering to when you want to do things with LED's. You shouldn't have to do instantiate your own new strip-object as you can use the one set up by the software itself. 1 2 3 LuxcenaNeo . strip or neo . strip","title":"class Strip"},{"location":"Scripting/SupportLib/#stripshow","text":"Display all the changes made to the LEDs, on the actual LEDs.","title":"Strip.show()"},{"location":"Scripting/SupportLib/#stripsetpixelcolorn-color","text":"Set LED at position n to the provided 24-bit color value (in RGB order).","title":"Strip.setPixelColor(n, color)"},{"location":"Scripting/SupportLib/#stripsetpixelcolorxyx-y-color","text":"Set LED at position (x, y) in the defined matrix to the provided 24-bit color value (in RGB order).","title":"Strip.setPixelColorXY(x, y, color)"},{"location":"Scripting/SupportLib/#stripsetpixelcolorrgbn-red-green-blue-white-0","text":"Set LED at position n to the provided red, green, and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity).","title":"Strip.setPixelColorRGB(n, red, green, blue, white = 0)"},{"location":"Scripting/SupportLib/#stripsetpixelcolorxyrgbx-y-red-green-blue-white-0","text":"Set LED at position (x, y) in the defined matrix to the provided red, green, and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity).","title":"Strip.setPixelColorXYRGB(x, y, red, green, blue, white = 0)"},{"location":"Scripting/SupportLib/#stripsetsegmentcolorrgbsegment-red-green-blue-white-0","text":"Set a whole segment to the provided red, green and blue color. Each color component should be a value from 0 to 255 (where 0 is the lowest intensity and 255 is the highest intensity).","title":"Strip.setSegmentColorRGB(segment, red, green, blue, white = 0)"},{"location":"Scripting/SupportLib/#stripsetbrightnessbrightness","text":"Scale each LED in the buffer by the provided brightness. A brightness of 0 is the darkest and 255 is the brightest.","title":"Strip.setBrightness(brightness)"},{"location":"Scripting/SupportLib/#stripgetbrightness","text":"Get the brightness value for each LED in the buffer. A brightness of 0 is the darkest and 255 is the brightest.","title":"Strip.getBrightness():"},{"location":"Scripting/SupportLib/#stripgetpixels","text":"Return an object which allows access to the LED display data as if it were a sequence of 24-bit RGB values.","title":"Strip.getPixels():"},{"location":"Scripting/SupportLib/#stripnumpixels","text":"Return the number of pixels in the display.","title":"Strip.numPixels():"},{"location":"Scripting/SupportLib/#stripgetpixelcolorn","text":"Get the 24-bit RGB color value for the LED at position n.","title":"Strip.getPixelColor(n)"},{"location":"Scripting/SupportLib/#colorred-green-blue-white-0","text":"Convert the provided red, green, blue color to a 24-bit color value. Each color component should be a value 0-255 where 0 is the lowest intensity and 255 is the highest intensity.","title":"Color(red, green, blue, white = 0)"},{"location":"Scripting/SupportLib/#hexcolorvalue","text":"Convert the provided hexadecimal color to a 24-bit color value.","title":"hexColor(value)"},{"location":"Usage/CLI/","text":"Command line interface Important! This CLI assumes root access, so please run it with sudo Options sudo lux - neo uninstall Uninstall the whole thing. You will have to remove this script yourself. sudo lux - neo update ( skipNode ) Update to the newest version on the current branch. If skipNode is the second argument, npm won't be run. sudo lux - neo conf Open the strip-config in nano . sudo lux - neo start ( boot ) Start the server. If you add boot , it will start when the system boots: 1 sudo lux-neo start boot sudo lux - neo stop ( boot ) Stop the server. If you add boot , it will NOT start when the system boots: 1 sudo lux-neo start boot sudo lux - neo status This will output the status of the app. First it reports if the service is running, and some general info. Then it prints the systemd-status report. Example output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Luxcena-neo-cli [args: 'status'] \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Service active: yes \u2502 \u2502 Starts on boot: yes \u2502 \u2502 Has failed: no \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2501\u2501\u2501Service status\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u25cf luxcena-neo.service - Luxcena Neo Loaded: loaded (/etc/systemd/system/luxcena-neo.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2018-12-05 22:55:28 UTC; 6min ago Main PID: 2365 (luxcena-neo.sh) CGroup: /system.slice/luxcena-neo.service \u251c\u25002365 /bin/bash /home/lux-neo/src/bin/luxcena-neo.sh \u2514\u25002367 node /home/lux-neo/src/app.js Dec 05 22:55:28 LUXCENA-STUE-SKAP systemd[1]: Started Luxcena Neo. \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 sudo lux - neo log service / app This shows the last 20 lines of the chosen log-file. And stays open to show all new entries. Example output: 1 2 3 4 5 Luxcena-neo-cli [args: 'log app'] \u2501\u2501\u2501App log (press ctrl+c to exit)\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 [3.11.2018 23:5:21:401] EVENT Starting Luxcena-Neo... [3.11.2018 23:5:22:462] SUCCESS Webserver now listening at *:8080 sudo lux - neo version Currently not really doing anything usefull apart from showing which branch you are on. Example output: 1 2 3 4 5 6 Luxcena-neo-cli [args: 'version'] \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Version: Unknown \u2502 \u2502 branch : dev \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f sudo lux - neo selectBranch < branch > This will change what branch you are on to . Stashing changes (shouldn't be a concern, but just saying it anyways). Note Please note that the version-checker now will just be useless, as it does not now what branch we really are on.","title":"CLI"},{"location":"Usage/CLI/#command-line-interface","text":"Important! This CLI assumes root access, so please run it with sudo","title":"Command line interface"},{"location":"Usage/CLI/#options","text":"","title":"Options"},{"location":"Usage/CLI/#sudo-lux-neo-uninstall","text":"Uninstall the whole thing. You will have to remove this script yourself.","title":"sudo lux-neo uninstall"},{"location":"Usage/CLI/#sudo-lux-neo-update-skipnode","text":"Update to the newest version on the current branch. If skipNode is the second argument, npm won't be run.","title":"sudo lux-neo update (skipNode)"},{"location":"Usage/CLI/#sudo-lux-neo-conf","text":"Open the strip-config in nano .","title":"sudo lux-neo conf"},{"location":"Usage/CLI/#sudo-lux-neo-start-boot","text":"Start the server. If you add boot , it will start when the system boots: 1 sudo lux-neo start boot","title":"sudo lux-neo start (boot)"},{"location":"Usage/CLI/#sudo-lux-neo-stop-boot","text":"Stop the server. If you add boot , it will NOT start when the system boots: 1 sudo lux-neo start boot","title":"sudo lux-neo stop (boot)"},{"location":"Usage/CLI/#sudo-lux-neo-status","text":"This will output the status of the app. First it reports if the service is running, and some general info. Then it prints the systemd-status report. Example output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Luxcena-neo-cli [args: 'status'] \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Service active: yes \u2502 \u2502 Starts on boot: yes \u2502 \u2502 Has failed: no \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2501\u2501\u2501Service status\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u25cf luxcena-neo.service - Luxcena Neo Loaded: loaded (/etc/systemd/system/luxcena-neo.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2018-12-05 22:55:28 UTC; 6min ago Main PID: 2365 (luxcena-neo.sh) CGroup: /system.slice/luxcena-neo.service \u251c\u25002365 /bin/bash /home/lux-neo/src/bin/luxcena-neo.sh \u2514\u25002367 node /home/lux-neo/src/app.js Dec 05 22:55:28 LUXCENA-STUE-SKAP systemd[1]: Started Luxcena Neo. \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501","title":"sudo lux-neo status"},{"location":"Usage/CLI/#sudo-lux-neo-log-serviceapp","text":"This shows the last 20 lines of the chosen log-file. And stays open to show all new entries. Example output: 1 2 3 4 5 Luxcena-neo-cli [args: 'log app'] \u2501\u2501\u2501App log (press ctrl+c to exit)\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 [3.11.2018 23:5:21:401] EVENT Starting Luxcena-Neo... [3.11.2018 23:5:22:462] SUCCESS Webserver now listening at *:8080","title":"sudo lux-neo log service/app"},{"location":"Usage/CLI/#sudo-lux-neo-version","text":"Currently not really doing anything usefull apart from showing which branch you are on. Example output: 1 2 3 4 5 6 Luxcena-neo-cli [args: 'version'] \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Version: Unknown \u2502 \u2502 branch : dev \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"sudo lux-neo version"},{"location":"Usage/CLI/#sudo-lux-neo-selectbranch-branch","text":"This will change what branch you are on to . Stashing changes (shouldn't be a concern, but just saying it anyways). Note Please note that the version-checker now will just be useless, as it does not now what branch we really are on.","title":"sudo lux-neo selectBranch &lt;branch&gt;"},{"location":"Usage/Configuration/","text":"Configuration How to setup luxcena-neo to work with your setup 1 $ sudo lux-neo conf When running the command above, a config file should appear in the editor 'nano'. 1 2 3 4 5 6 7 8 9 10 11 { \"led_count\" : 53 , \"segments\" : [], \"matrix\" : [], \"segmentConfiguration\" : \"snake\" , \"led_pin\" : 18 , \"led_freq_hz\" : 800000 , \"led_dma\" : 10 , \"led_invert\" : false , \"led_channel\" : 0 } Tip - Change editor If you rather want to use vim or another editor, the file is at / home / lux - neo / userdata / config / strip . json led_count This is the number of LED's you want to control. segments This is a simple list, here you should add the lenghts of all your segments. Please enter the \"real\" length, and don't start counting from 0. If you just want one segment, you should just have one element in the list, which is the number of led's you are controlling. When summing this list, it should check out with the \"led-count\"-option. matrix This is a two dimensonal array, used to arrange the segments in a matrix of your likings. Here you enter the segment-number to represent them. In the example above, all the segments are in one line. If you want to have them in a square, it could look like this: Warning If you don't have a reference to all the segments or something, the matrix setup will fail. And fall back to 'segmentsconfiguration' segmentconfiguration If the matrix-option is empty or badly setup. The matrix will be set up using one of these defaults: 1 2 3 \"snake\" : \"line\" : \"random\" : led_pin If using the luxcena-shield, you shouldn't have to worry about this option. But set it to the GPIO-port connected to your pixel's din-port. Warning If using a newer RPi (3 or newer), leave this as 10! Or your file-system might crash. This is the dma-channel used to generate the data-stream. If you for some reason need channel 10 for something else, you can change it. But i strongly recommend leaving it to 10! led_invert This should not be touched, unless you are using a inverting level converter. led_channel Leave this as default unless you know what you are doing. Now you might want to take a look at the command line interface .","title":"Configuration"},{"location":"Usage/Configuration/#configuration","text":"How to setup luxcena-neo to work with your setup 1 $ sudo lux-neo conf When running the command above, a config file should appear in the editor 'nano'. 1 2 3 4 5 6 7 8 9 10 11 { \"led_count\" : 53 , \"segments\" : [], \"matrix\" : [], \"segmentConfiguration\" : \"snake\" , \"led_pin\" : 18 , \"led_freq_hz\" : 800000 , \"led_dma\" : 10 , \"led_invert\" : false , \"led_channel\" : 0 } Tip - Change editor If you rather want to use vim or another editor, the file is at / home / lux - neo / userdata / config / strip . json","title":"Configuration"},{"location":"Usage/Configuration/#led_count","text":"This is the number of LED's you want to control.","title":"led_count"},{"location":"Usage/Configuration/#segments","text":"This is a simple list, here you should add the lenghts of all your segments. Please enter the \"real\" length, and don't start counting from 0. If you just want one segment, you should just have one element in the list, which is the number of led's you are controlling. When summing this list, it should check out with the \"led-count\"-option.","title":"segments"},{"location":"Usage/Configuration/#matrix","text":"This is a two dimensonal array, used to arrange the segments in a matrix of your likings. Here you enter the segment-number to represent them. In the example above, all the segments are in one line. If you want to have them in a square, it could look like this: Warning If you don't have a reference to all the segments or something, the matrix setup will fail. And fall back to 'segmentsconfiguration'","title":"matrix"},{"location":"Usage/Configuration/#segmentconfiguration","text":"If the matrix-option is empty or badly setup. The matrix will be set up using one of these defaults: 1 2 3 \"snake\" : \"line\" : \"random\" :","title":"segmentconfiguration"},{"location":"Usage/Configuration/#led_pin","text":"If using the luxcena-shield, you shouldn't have to worry about this option. But set it to the GPIO-port connected to your pixel's din-port. Warning If using a newer RPi (3 or newer), leave this as 10! Or your file-system might crash. This is the dma-channel used to generate the data-stream. If you for some reason need channel 10 for something else, you can change it. But i strongly recommend leaving it to 10!","title":"led_pin"},{"location":"Usage/Configuration/#led_invert","text":"This should not be touched, unless you are using a inverting level converter.","title":"led_invert"},{"location":"Usage/Configuration/#led_channel","text":"Leave this as default unless you know what you are doing. Now you might want to take a look at the command line interface .","title":"led_channel"},{"location":"Usage/Install/","text":"Installation If you want to install luxcena-neo to use it, these are the instructions: Requirements The luxcena-shield Access to the raspberry pi (SSH or direct) Root access (preferably through the sudo command) Install Start with logging into your Raspberry Pi Run these commands 1 2 3 git clone https://github.com/JakobST1n/Luxcena-Neo cd Luxcena-Neo sudo ./bin/install.sh Follow the instructions on screen. You should answer yes to most of the questions. The install-process might seem to hang, but there is just no output being sent to the console. If you want to see a bit more verbose output. Open another terminal session, and run this command: 1 tail -n 10 -f /tmp/luxcena-neo.install.log This is also where you will find possible reasons for a failed install. Luxcena-Neo should now be installed. Start it with this command 1 luxcena-neo start neo\":\"luxcena-neo Troubleshooting We haven't encountered any troubles yet, but once we do, we will post fix'es here. You should now be all set to configuring luxcena-neo .","title":"Install"},{"location":"Usage/Install/#installation","text":"If you want to install luxcena-neo to use it, these are the instructions:","title":"Installation"},{"location":"Usage/Install/#requirements","text":"The luxcena-shield Access to the raspberry pi (SSH or direct) Root access (preferably through the sudo command)","title":"Requirements"},{"location":"Usage/Install/#install","text":"Start with logging into your Raspberry Pi Run these commands 1 2 3 git clone https://github.com/JakobST1n/Luxcena-Neo cd Luxcena-Neo sudo ./bin/install.sh Follow the instructions on screen. You should answer yes to most of the questions. The install-process might seem to hang, but there is just no output being sent to the console. If you want to see a bit more verbose output. Open another terminal session, and run this command: 1 tail -n 10 -f /tmp/luxcena-neo.install.log This is also where you will find possible reasons for a failed install. Luxcena-Neo should now be installed. Start it with this command 1 luxcena-neo start neo\":\"luxcena-neo","title":"Install"},{"location":"Usage/Install/#troubleshooting","text":"We haven't encountered any troubles yet, but once we do, we will post fix'es here. You should now be all set to configuring luxcena-neo .","title":"Troubleshooting"}]}